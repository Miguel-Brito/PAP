# -*- coding: utf-8 -*-

from datetime import datetime
from odoo import api, fields, models
from datetime import datetime, date
from dateutil.relativedelta import relativedelta
from odoo.exceptions import ValidationError, UserError

class WorkTypeWebDirectory(models.Model):

    _name = "worktype"
    _description = "Budget Work Type"
    
    name = fields.Char(string="Name")
    interest_category_id = fields.Many2one('res.partner.category')
    description = fields.Text(string="Description")

		
class BudgetWebDirectory(models.Model):

    _name = "budget"
    _description = "Budgets"
    
    accepting_date = fields.Date(string="Date until proposals can be sent")
    partner_id = fields.Many2one('res.partner', string="Partner Budgets")
    name = fields.Char(
        'Number', default=lambda self: self.env['ir.sequence'].next_by_code('budget.code.serial'),
        required=True, readonly=True, help="Unique Process/Serial Number")
    work_type = fields.Many2one('worktype', string="Budget work type")
    country_id = fields.Many2one('res.country', string='Country', required=True, default= 185)
    state_id = fields.Many2one('res.country.state', string="State", domain="[('country_id', '=', country_id)]")
    city = fields.Char(string="City")
    description = fields.Text(string="Description")
    min_price = fields.Float(string="Minimum Price")
    max_price = fields.Float(string="Maximum Price")
    state = fields.Selection([('draft', 'Draft'), ('confirmed', 'Confirmed'), ('done', 'Done') ],
                             'State', readonly=True,
                             default=lambda *a: 'draft')
    @api.one
    def confirm_in_progress(self):
        self.state = 'confirmed'
        
    @api.one
    def confirm_to_draft(self):
        self.state = 'draft'        
        

class ProposalWebDirectory(models.Model):

    _name = "proposal"
    _description = "Budgets Proposals"

    name = fields.Char(
        'Number', default=lambda self: self.env['ir.sequence'].next_by_code('proposal.code.serial'),
        required=True, readonly=True, help="Unique Process/Serial Number")

    budget_id = fields.Many2one('budget', domain="[('state','=','confirmed')]", string="Budget")
    partner_id = fields.Many2one('res.partner', domain="[('pro','=',True)]" ,string="Partner Budgets")
    description = fields.Text(string="Description")
    exp_start_date = fields.Date(string="Expected start date")
    exp_duration = fields.Integer(string="Expected duration")
    time_type = fields.Selection([('hours', 'Hours'), ('days', 'Days'), ('months', 'Months')], 'State', default='days')
    state = fields.Selection([('draft', 'Draft'), ('confirmed', 'Confirmed'), ('accepted', 'Accepted'), ('rejected', 'Rejected')],
                             'State', readonly=True,
                             default=lambda *a: 'draft')

    @api.one
    def confirm_in_progress(self):
        self.state = 'confirmed'
        

    @api.one
    def accept_prop(self):
        self.state = 'accepted'
        self.budget_id.state = 'done'
        if self.time_type == 'hours':
            exp_end_date = fields.Datetime.from_string(self.exp_start_date) +  relativedelta(hours=self.exp_duration)
        elif self.time_type == 'days':
            exp_end_date = fields.Datetime.from_string(self.exp_start_date) +  relativedelta(days=self.exp_duration)   
        elif self.time_type == 'months':
            exp_end_date = fields.Datetime.from_string(self.exp_start_date) +  relativedelta(months=self.exp_duration)
        
        
        
        record = self.env['service'].create({'proposal_id': self.id, 'client_id': self.budget_id.partner_id.id, 'pro_id': self.partner_id.id, 'work_type_id': self.budget_id.work_type.id, 'budget_id': self.budget_id.id, 'exp_end_date':exp_end_date})        
        
        
        for prop in self.env['proposal'].search([('budget_id','=',int(self.budget_id))]):
            if prop.id != self.id:
            	prop.state = 'rejected'
            		
    
    @api.one
    def confirm_to_draft(self):
        self.state = 'draft'
        
    @api.onchange('exp_start_date')
    @api.constrains('exp_start_date')
    def exp_start_date_check(self):

        if self.exp_start_date:
            if self.exp_start_date <= datetime.now().strftime('%Y/%m/%d'):
                raise ValidationError('Start date must be greater than current date')
            elif self.exp_start_date <= budget_id.accepting_date:
                raise ValidationError('The start date must be greater than the date until proposals are accepted')
 
 
 
class ServiceWebDirectory(models.Model):

    _name = "service"
    _description = "Services"

    name = fields.Char(
        'Number', default=lambda self: self.env['ir.sequence'].next_by_code('service.code.serial'),
        required=True, readonly=True, help="Unique Process/Serial Number")

    
    proposal_id = fields.Many2one('proposal',string="Proposal")
    budget_id = fields.Many2one('budget', string="Budgets Proposals")
    
    pro_id = fields.Many2one('res.partner', domain="[('pro','=',True)]" ,string="Professional")
    client_id = fields.Many2one('res.partner', string="Client")
    work_type_id = fields.Many2one('worktype', string="Service work type")
    
    review_text = fields.Text(string="Message")
    review_star = fields.Float(size=8, string="Rating")
    exp_end_date = fields.Date(string="Expected service end date")
    state = fields.Selection([('scheduled', 'Scheduled'), ('in_execution', 'In Execution'), ('done', 'Done')],
                             'State', readonly=True,
                             default=lambda *a: 'scheduled')
    
    
    @api.onchange('proposal_id') 
    def get_client(self):
        self.client_id = self.proposal_id.budget_id.partner_id
        
    @api.onchange('proposal_id')    
    def get_pro(self):
        self.pro_id = self.proposal_id.partner_id  
         
    @api.onchange('proposal_id')   
    def get_work_type(self):
        self.work_type_id = self.proposal_id.budget_id.work_type.id              
    
    @api.onchange('proposal_id')     	
    def get_end_date(self):
    	  if self.proposal_id.time_type == 'hours':
            self.exp_end_date = fields.Datetime.from_string(self.proposal_id.exp_start_date) +  relativedelta(hours=self.proposal_id.exp_duration)
    	  elif self.proposal_id.time_type == 'days':
            self.exp_end_date = fields.Datetime.from_string(self.proposal_id.exp_start_date) +  relativedelta(days=self.proposal_id.exp_duration)   
    	  elif self.proposal_id.time_type == 'months':
            self.exp_end_date = fields.Datetime.from_string(self.proposal_id.exp_start_date) +  relativedelta(months=self.proposal_id.exp_duration)   
    
	

	

	

	
	
	
	
	